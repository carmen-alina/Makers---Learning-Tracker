def encode(plaintext, key)
  cipher = key.chars.uniq + (('a'..'z').to_a - key.chars)
  # p ('a'..'z').to_a
  # p "this is the value of #{plaintext.chars}"
  ciphertext_chars = plaintext.chars.map do |char|
    p char
    p cipher.find_index(char)
    p 65 + cipher.find_index(char)
  #   p cipher.find_index(char)
    p (65 + cipher.find_index(char)).chr
  end
  ciphertext_chars.join
end

# we run this method in irb
# got an error called TypeError (nil can't be coerced into Integer)
# the error is from line 3 to line 4
# is generated by the "+" method that can't be call on nil
# we need to get some visibility to understand from where the nil value comes
# we will print the plaintext.chars
# plaintext.chars splits letter by letter the argument passed to the plaintext and saves it in an array
# we will print the value of cipher.find_index(char)
# after printing the indexes we see that one of the values in nil
# I will print both each character and its index to see from where comes the nil value
# z returns a nil value
# I will print the cipher to understand what it generates
# it returns and array of letters that includes: the unique letters of the key & the rest of the alphabet less the secretkey
# however, z seems to be missing
# I'll print ('a'...'z').to_a  to see what generates, as this is the only place where z appears
# the array generated by ('a'...'z').to_a doesn't include a z
# we will fix this by usig .. inclusive
# now I expect the encode method to work
# It worked.

def decode(ciphertext, key)
  cipher = key.chars.uniq + (('a'..'z').to_a - key.chars)
  plaintext_chars = ciphertext.chars.map do |char|
    # p char
    # p 65 - char.ord
    # p cipher[65 - char.ord]
    # p char.ord
    cipher[char.ord - 65]
  end
  plaintext_chars.join
end

# Now, moving to the decode method. We run the method in irb to see the error meassage
# The output is not similar to the one expected
# "uixschlulaegtdyxmarxvuixfospmaj"
# "theswiftfoxjumpedoverthelazydog"
# the cipher is identical in both methods so I expect the (a'...'z').to_a to generate the same error
# we fix this by using inclusive ..
# we will run the test again
# no error message, but still not the expected result
# "vjzsrimvmbchkfaznbtzwvjzgpeqnbl" instead of
# "theswiftfoxjumpedoverthelazydog"
# I don't know what char.ord returns. So I'll print this
# I don't understand ord method I will google it
# It looks like there is an error in the way index of the cipher array is computed.
# It is returning other letters
# To get some visibility I will print in the encode method the letter, its ordinal number, its initial index in the plaintext array and the new computed ordinal number of the letter that will get printed
# In the decode method I'll print and its index in the cipher array
# index has the right value but the wrong sign (is negative).
# Order of this subtraction should be changed. 65 - char.ord
# It worked

# Intended output:
#
# > encode("theswiftfoxjumpedoverthelazydog", "secretkey")
# => "EMBAXNKEKSYOVQTBJSWBDEMBPHZGJSL"
#
# > decode("EMBAXNKEKSYOVQTBJSWBDEMBPHZGJSL", "secretkey")
# => "theswiftfoxjumpedoverthelazydog"
